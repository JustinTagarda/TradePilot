@page "/dashboard"
@page "/dashboard/{SourceId}"
@implements IAsyncDisposable
@inject IMtApiClient ApiClient
@inject ISnapshotPollingService PollingService
@inject HttpClient ApiHttpClient

@using Microsoft.AspNetCore.SignalR.Client

<PageTitle>Dashboard</PageTitle>

<h1>Dashboard</h1>

@if (!string.IsNullOrWhiteSpace(SourceId))
{
    <p class="text-muted">
        Update mode: <strong>@_updateMode</strong>
        @if (!string.IsNullOrWhiteSpace(_updateModeDetail))
        {
            <span> (@_updateModeDetail)</span>
        }
    </p>
}

@if (string.IsNullOrWhiteSpace(SourceId))
{
    <p>Select a source from the <a href="/sources">Sources</a> page.</p>
}
else if (_isLoading)
{
    <p>Loading latest snapshot for <strong>@SourceId</strong>...</p>
}
else if (!string.IsNullOrWhiteSpace(_error))
{
    <div class="alert alert-danger" role="alert">@_error</div>
}
else if (_snapshot is null)
{
    <p>No snapshot available for source <strong>@SourceId</strong>.</p>
}
else
{
    <section class="mb-4">
        <h2>Account</h2>
        <table class="table table-sm">
            <tbody>
                <tr><th>Source ID</th><td>@_snapshot.SourceId</td></tr>
                <tr><th>Last Update (UTC)</th><td>@_snapshot.TimestampUtc.ToString("yyyy-MM-dd HH:mm:ss")</td></tr>
                <tr><th>Broker</th><td>@_snapshot.Account.Broker</td></tr>
                <tr><th>Server</th><td>@_snapshot.Account.Server</td></tr>
                <tr><th>Login</th><td>@_snapshot.Account.Login</td></tr>
                <tr><th>Currency</th><td>@_snapshot.Account.Currency</td></tr>
                <tr><th>Balance</th><td>@_snapshot.Account.Balance</td></tr>
                <tr><th>Equity</th><td>@_snapshot.Account.Equity</td></tr>
                <tr><th>Margin</th><td>@_snapshot.Account.Margin</td></tr>
                <tr><th>Free Margin</th><td>@_snapshot.Account.FreeMargin</td></tr>
                <tr><th>Margin Level</th><td>@_snapshot.Account.MarginLevel</td></tr>
            </tbody>
        </table>
    </section>

    <section class="mb-4">
        <h2>Positions (@_snapshot.Positions.Count)</h2>
        @if (_snapshot.Positions.Count == 0)
        {
            <p>No open positions.</p>
        }
        else
        {
            <div class="table-responsive">
                <table class="table table-striped table-sm">
                    <thead>
                        <tr>
                            <th>Ticket</th>
                            <th>Symbol</th>
                            <th>Side</th>
                            <th>Volume</th>
                            <th>Open</th>
                            <th>SL</th>
                            <th>TP</th>
                            <th>Current</th>
                            <th>Profit</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var position in _snapshot.Positions)
                        {
                            <tr>
                                <td>@position.Ticket</td>
                                <td>@position.Symbol</td>
                                <td>@position.Side</td>
                                <td>@position.Volume</td>
                                <td>@position.OpenPrice</td>
                                <td>@position.StopLoss</td>
                                <td>@position.TakeProfit</td>
                                <td>@position.CurrentPrice</td>
                                <td>@position.Profit</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
    </section>

    <section>
        <h2>Orders (@_snapshot.Orders.Count)</h2>
        @if (_snapshot.Orders.Count == 0)
        {
            <p>No pending orders.</p>
        }
        else
        {
            <div class="table-responsive">
                <table class="table table-striped table-sm">
                    <thead>
                        <tr>
                            <th>Ticket</th>
                            <th>Symbol</th>
                            <th>Type</th>
                            <th>Volume</th>
                            <th>Price</th>
                            <th>SL</th>
                            <th>TP</th>
                            <th>Time (UTC)</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var order in _snapshot.Orders)
                        {
                            <tr>
                                <td>@order.Ticket</td>
                                <td>@order.Symbol</td>
                                <td>@order.Type</td>
                                <td>@order.Volume</td>
                                <td>@order.Price</td>
                                <td>@order.StopLoss</td>
                                <td>@order.TakeProfit</td>
                                <td>@order.TimeUtc.ToString("yyyy-MM-dd HH:mm:ss")</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
    </section>
}

@code {
    private static readonly TimeSpan PollingInterval = TimeSpan.FromSeconds(2);

    [Parameter]
    public string? SourceId { get; set; }

    private MtSnapshot? _snapshot;
    private bool _isLoading;
    private string? _error;
    private string _updateMode = "Idle";
    private string? _updateModeDetail;

    private CancellationTokenSource? _sessionCts;
    private CancellationTokenSource? _pollingCts;
    private Task? _pollingTask;
    private HubConnection? _hubConnection;
    private readonly SemaphoreSlim _snapshotRefreshGate = new(1, 1);

    protected override async Task OnParametersSetAsync()
    {
        await StopStreamingAsync();

        _snapshot = null;
        _error = null;
        _updateMode = "Idle";
        _updateModeDetail = null;

        if (string.IsNullOrWhiteSpace(SourceId))
        {
            _isLoading = false;
            return;
        }

        _isLoading = true;
        _sessionCts = new CancellationTokenSource();

        await RefreshLatestSnapshotAsync(SourceId, _sessionCts.Token);
        if (_sessionCts.IsCancellationRequested)
        {
            return;
        }

        await StartRealtimeAsync(SourceId, _sessionCts.Token);
    }

    private async Task StartRealtimeAsync(string sourceId, CancellationToken cancellationToken)
    {
        await SetUpdateModeAsync("SignalR (connecting)", null);

        var connection = new HubConnectionBuilder()
            .WithUrl(BuildHubUri())
            .WithAutomaticReconnect()
            .Build();

        connection.On<MtSnapshotUpdate>("SnapshotUpdated", update => OnSnapshotUpdatedAsync(sourceId, update, cancellationToken));
        connection.Reconnecting += error => OnRealtimeReconnectingAsync(sourceId, error);
        connection.Reconnected += _ => OnRealtimeReconnectedAsync(sourceId, cancellationToken);
        connection.Closed += error => OnRealtimeClosedAsync(sourceId, error, cancellationToken);

        _hubConnection = connection;

        try
        {
            await connection.StartAsync(cancellationToken);
            await connection.SendAsync("SubscribeSource", sourceId, cancellationToken);
            await StopPollingAsync();
            await SetUpdateModeAsync("SignalR (connected)", null);
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
        }
        catch (Exception ex)
        {
            await SetUpdateModeAsync("Polling fallback", $"SignalR unavailable: {ex.Message}");
            await StartPollingAsync(sourceId, cancellationToken);
        }
    }

    private Task OnSnapshotUpdatedAsync(string sourceId, MtSnapshotUpdate update, CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            return Task.CompletedTask;
        }

        if (!string.Equals(update.SourceId, sourceId, StringComparison.OrdinalIgnoreCase))
        {
            return Task.CompletedTask;
        }

        return RefreshLatestSnapshotAsync(sourceId, cancellationToken);
    }

    private async Task OnRealtimeReconnectingAsync(string sourceId, Exception? error)
    {
        if (_sessionCts?.IsCancellationRequested ?? true)
        {
            return;
        }

        await SetUpdateModeAsync("Polling fallback", $"SignalR reconnecting: {error?.Message ?? "connection lost"}");
        await StartPollingAsync(sourceId, _sessionCts.Token);
    }

    private async Task OnRealtimeReconnectedAsync(string sourceId, CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested || _hubConnection is null)
        {
            return;
        }

        try
        {
            await _hubConnection.SendAsync("SubscribeSource", sourceId, cancellationToken);
            await StopPollingAsync();
            await SetUpdateModeAsync("SignalR (connected)", null);
            await RefreshLatestSnapshotAsync(sourceId, cancellationToken);
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
        }
        catch (Exception ex)
        {
            await SetUpdateModeAsync("Polling fallback", $"SignalR re-subscribe failed: {ex.Message}");
            await StartPollingAsync(sourceId, cancellationToken);
        }
    }

    private async Task OnRealtimeClosedAsync(string sourceId, Exception? error, CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }

        await SetUpdateModeAsync("Polling fallback", $"SignalR disconnected: {error?.Message ?? "closed"}");
        await StartPollingAsync(sourceId, cancellationToken);
    }

    private Uri BuildHubUri()
    {
        var baseAddress = ApiHttpClient.BaseAddress;
        if (baseAddress is null)
        {
            throw new InvalidOperationException("API base address is not configured.");
        }

        return new Uri(baseAddress, "hubs/mt");
    }

    private Task StartPollingAsync(string sourceId, CancellationToken sessionToken)
    {
        if (_pollingCts is not null)
        {
            return Task.CompletedTask;
        }

        _pollingCts = CancellationTokenSource.CreateLinkedTokenSource(sessionToken);
        _pollingTask = PollingService.PollLatestSnapshotAsync(
            sourceId,
            PollingInterval,
            OnPollingSnapshotAsync,
            OnPollingErrorAsync,
            _pollingCts.Token);

        return Task.CompletedTask;
    }

    private Task OnPollingSnapshotAsync(MtSnapshot? snapshot)
    {
        return InvokeAsync(() =>
        {
            _snapshot = snapshot;
            _error = null;
            _isLoading = false;
            StateHasChanged();
        });
    }

    private Task OnPollingErrorAsync(Exception exception)
    {
        return InvokeAsync(() =>
        {
            _error = $"Unable to load dashboard data: {exception.Message}";
            _isLoading = false;
            StateHasChanged();
        });
    }

    private async Task RefreshLatestSnapshotAsync(string sourceId, CancellationToken cancellationToken)
    {
        await _snapshotRefreshGate.WaitAsync(cancellationToken);
        try
        {
            var snapshot = await ApiClient.GetLatestSnapshotAsync(sourceId, cancellationToken);
            await InvokeAsync(() =>
            {
                _snapshot = snapshot;
                _error = null;
                _isLoading = false;
                StateHasChanged();
            });
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
        }
        catch (Exception ex)
        {
            await InvokeAsync(() =>
            {
                _error = $"Unable to load dashboard data: {ex.Message}";
                _isLoading = false;
                StateHasChanged();
            });
        }
        finally
        {
            _snapshotRefreshGate.Release();
        }
    }

    private Task SetUpdateModeAsync(string mode, string? detail)
    {
        return InvokeAsync(() =>
        {
            _updateMode = mode;
            _updateModeDetail = detail;
            StateHasChanged();
        });
    }

    private async Task StopPollingAsync()
    {
        if (_pollingCts is null)
        {
            return;
        }

        _pollingCts.Cancel();
        if (_pollingTask is not null)
        {
            try
            {
                await _pollingTask;
            }
            catch (OperationCanceledException)
            {
            }
        }

        _pollingCts.Dispose();
        _pollingCts = null;
        _pollingTask = null;
    }

    private async Task StopRealtimeAsync()
    {
        if (_hubConnection is null)
        {
            return;
        }

        try
        {
            if (!string.IsNullOrWhiteSpace(SourceId))
            {
                await _hubConnection.SendAsync("UnsubscribeSource", SourceId);
            }
        }
        catch
        {
        }

        await _hubConnection.DisposeAsync();
        _hubConnection = null;
    }

    private async Task StopStreamingAsync()
    {
        if (_sessionCts is not null)
        {
            _sessionCts.Cancel();
        }

        await StopPollingAsync();
        await StopRealtimeAsync();

        if (_sessionCts is not null)
        {
            _sessionCts.Dispose();
            _sessionCts = null;
        }
    }

    public async ValueTask DisposeAsync()
    {
        await StopStreamingAsync();
        _snapshotRefreshGate.Dispose();
    }
}
